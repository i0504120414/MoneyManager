"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/transactions/page",{

/***/ "(app-pages-browser)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CREDIT_CARD_TYPES: function() { return /* binding */ CREDIT_CARD_TYPES; },\n/* harmony export */   api: function() { return /* binding */ api; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/index.mjs\");\n\nconst supabaseUrl = \"https://zqfulrwysdtnvogicldy.supabase.co\";\nconst supabaseAnonKey = \"sb_publishable_krVfM1a4y5BtRrFEX4hgxw_mE5XbEte\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Credit card types that should show upcoming charges instead of balance\nconst CREDIT_CARD_TYPES = [\n    \"isracard\",\n    \"amex\",\n    \"max\",\n    \"visaCal\"\n];\n// API functions\nconst api = {\n    // Accounts\n    async getAccounts () {\n        const { data, error } = await supabase.from(\"bank_accounts\").select(\"*\").eq(\"is_active\", true).or(\"is_cancelled.is.null,is_cancelled.eq.false\"); // Filter out cancelled cards\n        if (error) throw error;\n        return data;\n    },\n    // Get upcoming credit card charges (sum of charged_amount for pending transactions)\n    async getCreditCardUpcomingCharges (accountId) {\n        // Get transactions from current month that haven't been processed yet\n        const now = new Date();\n        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();\n        const endOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 2, 0).toISOString();\n        const { data, error } = await supabase.from(\"transactions\").select(\"charged_amount\").eq(\"account_id\", accountId).gte(\"date\", startOfMonth).lte(\"date\", endOfNextMonth);\n        if (error) throw error;\n        // Sum all charged amounts (they are negative for expenses)\n        const total = (data || []).reduce((sum, tx)=>sum + (tx.charged_amount || 0), 0);\n        return Math.abs(total); // Return as positive number\n    },\n    // Transactions\n    async getTransactions (filters) {\n        let query = supabase.from(\"transactions\").select(\"\\n        *,\\n        bank_accounts!inner(bank_type)\\n      \").order(\"date\", {\n            ascending: false\n        });\n        if (filters === null || filters === void 0 ? void 0 : filters.accountId) {\n            query = query.eq(\"account_id\", filters.accountId);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.startDate) {\n            query = query.gte(\"date\", filters.startDate);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.endDate) {\n            query = query.lte(\"date\", filters.endDate);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.search) {\n            query = query.ilike(\"description\", \"%\".concat(filters.search, \"%\"));\n        }\n        const { data, error } = await query.limit(500);\n        if (error) throw error;\n        return data;\n    },\n    async updateTransactionCategory (transactionIds, categoryId) {\n        const { error } = await supabase.from(\"transactions\").update({\n            category_id: categoryId\n        }).in(\"id\", transactionIds);\n        if (error) throw error;\n    },\n    // Categories\n    async getCategories () {\n        const { data, error } = await supabase.from(\"categories\").select(\"*\").order(\"name\");\n        if (error) throw error;\n        return data;\n    },\n    async createCategory (category) {\n        var _user_user;\n        const { data: user } = await supabase.auth.getUser();\n        const { data, error } = await supabase.from(\"categories\").insert([\n            {\n                ...category,\n                user_id: user === null || user === void 0 ? void 0 : (_user_user = user.user) === null || _user_user === void 0 ? void 0 : _user_user.id\n            }\n        ]).select().single();\n        if (error) throw error;\n        return data;\n    },\n    async updateCategory (id, updates) {\n        const { error } = await supabase.from(\"categories\").update(updates).eq(\"id\", id);\n        if (error) throw error;\n    },\n    // Recurring\n    async getRecurring () {\n        const { data, error } = await supabase.from(\"recurring\").select(\"*\").order(\"amount_avg\", {\n            ascending: false\n        });\n        if (error) throw error;\n        return data;\n    },\n    async getPendingRecurringCount () {\n        // Only count non-installment recurring as pending (installments are auto-approved)\n        const { count, error } = await supabase.from(\"recurring\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"is_confirmed\", false).neq(\"type\", \"installment\");\n        if (error) throw error;\n        return count || 0;\n    },\n    async confirmRecurring (id, confirmed) {\n        const { error } = await supabase.from(\"recurring\").update({\n            is_confirmed: confirmed\n        }).eq(\"id\", id);\n        if (error) throw error;\n    },\n    // Notifications\n    async getNotifications () {\n        const { data, error } = await supabase.from(\"notifications\").select(\"*\").order(\"created_at\", {\n            ascending: false\n        }).limit(50);\n        if (error) throw error;\n        return data;\n    },\n    async markNotificationRead (id) {\n        const { error } = await supabase.from(\"notifications\").update({\n            is_read: true\n        }).eq(\"id\", id);\n        if (error) throw error;\n    },\n    // Assignment Rules\n    async getAssignmentRules () {\n        const { data, error } = await supabase.from(\"assignment_rules\").select(\"*, categories(name)\").order(\"pattern\");\n        if (error) throw error;\n        return data;\n    },\n    async createAssignmentRule (rule) {\n        var _user_user;\n        const { data: user } = await supabase.auth.getUser();\n        const { data, error } = await supabase.from(\"assignment_rules\").insert([\n            {\n                ...rule,\n                user_id: user === null || user === void 0 ? void 0 : (_user_user = user.user) === null || _user_user === void 0 ? void 0 : _user_user.id,\n                is_active: true\n            }\n        ]).select().single();\n        if (error) throw error;\n        return data;\n    },\n    async deleteAssignmentRule (id) {\n        const { error } = await supabase.from(\"assignment_rules\").delete().eq(\"id\", id);\n        if (error) throw error;\n    },\n    async updateAssignmentRule (id, updates) {\n        const { error } = await supabase.from(\"assignment_rules\").update(updates).eq(\"id\", id);\n        if (error) throw error;\n    },\n    // Stats\n    async getCategoryStats (startDate, endDate) {\n        const { data, error } = await supabase.from(\"transactions\").select(\"\\n        category_id,\\n        charged_amount,\\n        categories(name, target_amount)\\n      \").gte(\"date\", startDate).lte(\"date\", endDate);\n        if (error) throw error;\n        return data;\n    },\n    // Reset all data (keeps bank_user_accounts credentials)\n    async resetAllData () {\n        // Delete in order due to foreign key constraints\n        // 1. Delete recurring (references bank_accounts)\n        const { error: recurringError } = await supabase.from(\"recurring\").delete().neq(\"id\", \"00000000-0000-0000-0000-000000000000\"); // Delete all\n        if (recurringError) throw recurringError;\n        // 2. Delete transactions (references bank_accounts)\n        const { error: txError } = await supabase.from(\"transactions\").delete().neq(\"id\", \"00000000-0000-0000-0000-000000000000\");\n        if (txError) throw txError;\n        // 3. Delete bank_accounts (references bank_user_accounts)\n        const { error: accountsError } = await supabase.from(\"bank_accounts\").delete().neq(\"id\", \"00000000-0000-0000-0000-000000000000\");\n        if (accountsError) throw accountsError;\n        // 4. Delete categories\n        const { error: catError } = await supabase.from(\"categories\").delete().neq(\"id\", \"00000000-0000-0000-0000-000000000000\");\n        if (catError) throw catError;\n        // 5. Delete assignment_rules\n        const { error: rulesError } = await supabase.from(\"assignment_rules\").delete().neq(\"id\", \"00000000-0000-0000-0000-000000000000\");\n        if (rulesError) throw rulesError;\n        // 6. Delete logs\n        const { error: logsError } = await supabase.from(\"logs\").delete().neq(\"id\", \"00000000-0000-0000-0000-000000000000\");\n        if (logsError) throw logsError;\n        // 7. Reset last_updated in bank_user_accounts to trigger full re-sync\n        const { error: updateError } = await supabase.from(\"bank_user_accounts\").update({\n            last_updated: null\n        }).neq(\"id\", \"00000000-0000-0000-0000-000000000000\");\n        if (updateError) throw updateError;\n    },\n    // Delete a bank user account and all its data\n    async deleteBankUserAccount (userAccountId) {\n        // CASCADE will handle bank_accounts, transactions, recurring\n        const { error } = await supabase.from(\"bank_user_accounts\").delete().eq(\"id\", userAccountId);\n        if (error) throw error;\n    },\n    // Get bank user accounts (for listing accounts to delete)\n    async getBankUserAccounts () {\n        const { data, error } = await supabase.from(\"bank_user_accounts\").select(\"id, bank_type, created_at\");\n        if (error) throw error;\n        return data;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUlxQixXQUFXLE1BQU1BO1FBRXJCLHNFQUFzRTtRQUN0RSxNQUFNLEVBQUU1RSxPQUFPNkUsV0FBVyxFQUFFLEdBQUcsTUFBTWxGLFNBQ2xDTSxJQUFJLENBQUMsc0JBQ0xtQyxNQUFNLENBQUM7WUFBRTBDLGNBQWM7UUFBSyxHQUM1QnZCLEdBQUcsQ0FBQyxNQUFNO1FBQ2IsSUFBSXNCLGFBQWEsTUFBTUE7SUFDekI7SUFFQSw4Q0FBOEM7SUFDOUMsTUFBTUUsdUJBQXNCQyxhQUFxQjtRQUMvQyw2REFBNkQ7UUFDN0QsTUFBTSxFQUFFaEYsS0FBSyxFQUFFLEdBQUcsTUFBTUwsU0FDckJNLElBQUksQ0FBQyxzQkFDTGtFLE1BQU0sR0FDTmhFLEVBQUUsQ0FBQyxNQUFNNkU7UUFDWixJQUFJaEYsT0FBTyxNQUFNQTtJQUNuQjtJQUVBLDBEQUEwRDtJQUMxRCxNQUFNaUY7UUFDSixNQUFNLEVBQUVsRixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1MLFNBQzNCTSxJQUFJLENBQUMsc0JBQ0xDLE1BQU0sQ0FBQztRQUNWLElBQUlGLE9BQU8sTUFBTUE7UUFDakIsT0FBT0Q7SUFDVDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9zdXBhYmFzZS50cz8wNmUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XHJcblxyXG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCE7XHJcbmNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZITtcclxuXHJcbmV4cG9ydCBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KTtcclxuXHJcbi8vIFR5cGVzIGZvciBkYXRhYmFzZSB0YWJsZXNcclxuZXhwb3J0IGludGVyZmFjZSBBY2NvdW50IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHVzZXJfYWNjb3VudF9pZDogc3RyaW5nO1xyXG4gIGJhbmtfbmFtZTogc3RyaW5nO1xyXG4gIGJhbmtfdHlwZTogc3RyaW5nO1xyXG4gIGFjY291bnRfbnVtYmVyPzogc3RyaW5nO1xyXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xyXG4gIGxhc3Rfc3luYz86IHN0cmluZztcclxuICBsYXN0X3VwZGF0ZWQ6IHN0cmluZztcclxuICBzdGF0dXM6ICdhY3RpdmUnIHwgJ2luYWN0aXZlJyB8ICdlcnJvcic7XHJcbiAgY3VycmVudF9iYWxhbmNlPzogbnVtYmVyO1xyXG4gIGJhbGFuY2U/OiBudW1iZXI7XHJcbiAgaXNfY2FuY2VsbGVkPzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbiB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBhY2NvdW50X2lkOiBzdHJpbmc7XHJcbiAgZGF0ZTogc3RyaW5nO1xyXG4gIHByb2Nlc3NlZF9kYXRlPzogc3RyaW5nO1xyXG4gIG9yaWdpbmFsX2Ftb3VudDogbnVtYmVyO1xyXG4gIG9yaWdpbmFsX2N1cnJlbmN5OiBzdHJpbmc7XHJcbiAgY2hhcmdlZF9hbW91bnQ6IG51bWJlcjtcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIG1lbW8/OiBzdHJpbmc7XHJcbiAgdHlwZTogc3RyaW5nO1xyXG4gIGNhdGVnb3J5X2lkPzogc3RyaW5nO1xyXG4gIGluc3RhbGxtZW50X251bWJlcj86IG51bWJlcjtcclxuICBpbnN0YWxsbWVudF90b3RhbD86IG51bWJlcjtcclxuICBoYXNoOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcnkge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdXNlcl9pZDogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICB0YXJnZXRfYW1vdW50PzogbnVtYmVyO1xyXG4gIGljb24/OiBzdHJpbmc7XHJcbiAgY29sb3I/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVjdXJyaW5nIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIGFjY291bnRfaWQ6IHN0cmluZztcclxuICB0eXBlOiAnaW5zdGFsbG1lbnQnIHwgJ2RpcmVjdF9kZWJpdCcgfCAnZGV0ZWN0ZWQnO1xyXG4gIGF2ZXJhZ2VfYW1vdW50OiBudW1iZXI7XHJcbiAgYW1vdW50X2F2ZzogbnVtYmVyO1xyXG4gIGV4cGVjdGVkX2RheT86IG51bWJlcjtcclxuICBkYXlfb2ZfbW9udGg/OiBudW1iZXI7XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICBpc19jb25maXJtZWQ6IGJvb2xlYW47XHJcbiAgaW5zdGFsbG1lbnRfdG90YWw/OiBudW1iZXI7IC8vIFRvdGFsIGluc3RhbGxtZW50c1xyXG4gIGluc3RhbGxtZW50X2N1cnJlbnQ/OiBudW1iZXI7IC8vIEN1cnJlbnQgaW5zdGFsbG1lbnQgd2hlbiBmaXJzdCBkZXRlY3RlZFxyXG4gIGZpcnN0X2RldGVjdGVkX2RhdGU/OiBzdHJpbmc7IC8vIERhdGUgd2hlbiBmaXJzdCBkZXRlY3RlZFxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBSZWN1cnJpbmdJdGVtID0gUmVjdXJyaW5nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBOb3RpZmljYXRpb24ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdXNlcl9pZDogc3RyaW5nO1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgbWVzc2FnZTogc3RyaW5nO1xyXG4gIGlzX3JlYWQ6IGJvb2xlYW47XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lnbm1lbnRSdWxlIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHVzZXJfaWQ6IHN0cmluZztcclxuICBwYXR0ZXJuOiBzdHJpbmc7XHJcbiAgY2F0ZWdvcnlfaWQ6IHN0cmluZztcclxuICBpc19hY3RpdmU6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8vIENyZWRpdCBjYXJkIHR5cGVzIHRoYXQgc2hvdWxkIHNob3cgdXBjb21pbmcgY2hhcmdlcyBpbnN0ZWFkIG9mIGJhbGFuY2VcclxuZXhwb3J0IGNvbnN0IENSRURJVF9DQVJEX1RZUEVTID0gWydpc3JhY2FyZCcsICdhbWV4JywgJ21heCcsICd2aXNhQ2FsJ107XHJcblxyXG4vLyBBUEkgZnVuY3Rpb25zXHJcbmV4cG9ydCBjb25zdCBhcGkgPSB7XHJcbiAgLy8gQWNjb3VudHNcclxuICBhc3luYyBnZXRBY2NvdW50cygpIHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdiYW5rX2FjY291bnRzJylcclxuICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcclxuICAgICAgLm9yKCdpc19jYW5jZWxsZWQuaXMubnVsbCxpc19jYW5jZWxsZWQuZXEuZmFsc2UnKTsgLy8gRmlsdGVyIG91dCBjYW5jZWxsZWQgY2FyZHNcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9LFxyXG5cclxuICAvLyBHZXQgdXBjb21pbmcgY3JlZGl0IGNhcmQgY2hhcmdlcyAoc3VtIG9mIGNoYXJnZWRfYW1vdW50IGZvciBwZW5kaW5nIHRyYW5zYWN0aW9ucylcclxuICBhc3luYyBnZXRDcmVkaXRDYXJkVXBjb21pbmdDaGFyZ2VzKGFjY291bnRJZDogc3RyaW5nKSB7XHJcbiAgICAvLyBHZXQgdHJhbnNhY3Rpb25zIGZyb20gY3VycmVudCBtb250aCB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgY29uc3Qgc3RhcnRPZk1vbnRoID0gbmV3IERhdGUobm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpLCAxKS50b0lTT1N0cmluZygpO1xyXG4gICAgY29uc3QgZW5kT2ZOZXh0TW9udGggPSBuZXcgRGF0ZShub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCkgKyAyLCAwKS50b0lTT1N0cmluZygpO1xyXG4gICAgXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgndHJhbnNhY3Rpb25zJylcclxuICAgICAgLnNlbGVjdCgnY2hhcmdlZF9hbW91bnQnKVxyXG4gICAgICAuZXEoJ2FjY291bnRfaWQnLCBhY2NvdW50SWQpXHJcbiAgICAgIC5ndGUoJ2RhdGUnLCBzdGFydE9mTW9udGgpXHJcbiAgICAgIC5sdGUoJ2RhdGUnLCBlbmRPZk5leHRNb250aCk7XHJcbiAgICBcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICBcclxuICAgIC8vIFN1bSBhbGwgY2hhcmdlZCBhbW91bnRzICh0aGV5IGFyZSBuZWdhdGl2ZSBmb3IgZXhwZW5zZXMpXHJcbiAgICBjb25zdCB0b3RhbCA9IChkYXRhIHx8IFtdKS5yZWR1Y2UoKHN1bSwgdHgpID0+IHN1bSArICh0eC5jaGFyZ2VkX2Ftb3VudCB8fCAwKSwgMCk7XHJcbiAgICByZXR1cm4gTWF0aC5hYnModG90YWwpOyAvLyBSZXR1cm4gYXMgcG9zaXRpdmUgbnVtYmVyXHJcbiAgfSxcclxuXHJcbiAgLy8gVHJhbnNhY3Rpb25zXHJcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zKGZpbHRlcnM/OiB7XHJcbiAgICBhY2NvdW50SWQ/OiBzdHJpbmc7XHJcbiAgICBzdGFydERhdGU/OiBzdHJpbmc7XHJcbiAgICBlbmREYXRlPzogc3RyaW5nO1xyXG4gICAgY2F0ZWdvcnk/OiBzdHJpbmc7XHJcbiAgICBzZWFyY2g/OiBzdHJpbmc7XHJcbiAgfSkge1xyXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3RyYW5zYWN0aW9ucycpXHJcbiAgICAgIC5zZWxlY3QoYFxyXG4gICAgICAgICosXHJcbiAgICAgICAgYmFua19hY2NvdW50cyFpbm5lcihiYW5rX3R5cGUpXHJcbiAgICAgIGApXHJcbiAgICAgIC5vcmRlcignZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcclxuXHJcbiAgICBpZiAoZmlsdGVycz8uYWNjb3VudElkKSB7XHJcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2FjY291bnRfaWQnLCBmaWx0ZXJzLmFjY291bnRJZCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZmlsdGVycz8uc3RhcnREYXRlKSB7XHJcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuZ3RlKCdkYXRlJywgZmlsdGVycy5zdGFydERhdGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZpbHRlcnM/LmVuZERhdGUpIHtcclxuICAgICAgcXVlcnkgPSBxdWVyeS5sdGUoJ2RhdGUnLCBmaWx0ZXJzLmVuZERhdGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZpbHRlcnM/LnNlYXJjaCkge1xyXG4gICAgICBxdWVyeSA9IHF1ZXJ5LmlsaWtlKCdkZXNjcmlwdGlvbicsIGAlJHtmaWx0ZXJzLnNlYXJjaH0lYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnkubGltaXQoNTAwKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9LFxyXG5cclxuICBhc3luYyB1cGRhdGVUcmFuc2FjdGlvbkNhdGVnb3J5KHRyYW5zYWN0aW9uSWRzOiBzdHJpbmdbXSwgY2F0ZWdvcnlJZDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgndHJhbnNhY3Rpb25zJylcclxuICAgICAgLnVwZGF0ZSh7IGNhdGVnb3J5X2lkOiBjYXRlZ29yeUlkIH0pXHJcbiAgICAgIC5pbignaWQnLCB0cmFuc2FjdGlvbklkcyk7XHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gIH0sXHJcblxyXG4gIC8vIENhdGVnb3JpZXNcclxuICBhc3luYyBnZXRDYXRlZ29yaWVzKCkge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2NhdGVnb3JpZXMnKVxyXG4gICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgLm9yZGVyKCduYW1lJyk7XHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgY3JlYXRlQ2F0ZWdvcnkoY2F0ZWdvcnk6IFBhcnRpYWw8Q2F0ZWdvcnk+KSB7XHJcbiAgICBjb25zdCB7IGRhdGE6IHVzZXIgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2NhdGVnb3JpZXMnKVxyXG4gICAgICAuaW5zZXJ0KFt7IC4uLmNhdGVnb3J5LCB1c2VyX2lkOiB1c2VyPy51c2VyPy5pZCB9XSlcclxuICAgICAgLnNlbGVjdCgpXHJcbiAgICAgIC5zaW5nbGUoKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9LFxyXG5cclxuICBhc3luYyB1cGRhdGVDYXRlZ29yeShpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPENhdGVnb3J5Pikge1xyXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2NhdGVnb3JpZXMnKVxyXG4gICAgICAudXBkYXRlKHVwZGF0ZXMpXHJcbiAgICAgIC5lcSgnaWQnLCBpZCk7XHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gIH0sXHJcblxyXG4gIC8vIFJlY3VycmluZ1xyXG4gIGFzeW5jIGdldFJlY3VycmluZygpIHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdyZWN1cnJpbmcnKVxyXG4gICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgLm9yZGVyKCdhbW91bnRfYXZnJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH0sXHJcblxyXG4gIGFzeW5jIGdldFBlbmRpbmdSZWN1cnJpbmdDb3VudCgpIHtcclxuICAgIC8vIE9ubHkgY291bnQgbm9uLWluc3RhbGxtZW50IHJlY3VycmluZyBhcyBwZW5kaW5nIChpbnN0YWxsbWVudHMgYXJlIGF1dG8tYXBwcm92ZWQpXHJcbiAgICBjb25zdCB7IGNvdW50LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3JlY3VycmluZycpXHJcbiAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXHJcbiAgICAgIC5lcSgnaXNfY29uZmlybWVkJywgZmFsc2UpXHJcbiAgICAgIC5uZXEoJ3R5cGUnLCAnaW5zdGFsbG1lbnQnKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICByZXR1cm4gY291bnQgfHwgMDtcclxuICB9LFxyXG5cclxuICBhc3luYyBjb25maXJtUmVjdXJyaW5nKGlkOiBzdHJpbmcsIGNvbmZpcm1lZDogYm9vbGVhbikge1xyXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3JlY3VycmluZycpXHJcbiAgICAgIC51cGRhdGUoeyBpc19jb25maXJtZWQ6IGNvbmZpcm1lZCB9KVxyXG4gICAgICAuZXEoJ2lkJywgaWQpO1xyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICB9LFxyXG5cclxuICAvLyBOb3RpZmljYXRpb25zXHJcbiAgYXN5bmMgZ2V0Tm90aWZpY2F0aW9ucygpIHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdub3RpZmljYXRpb25zJylcclxuICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgICAubGltaXQoNTApO1xyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH0sXHJcblxyXG4gIGFzeW5jIG1hcmtOb3RpZmljYXRpb25SZWFkKGlkOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdub3RpZmljYXRpb25zJylcclxuICAgICAgLnVwZGF0ZSh7IGlzX3JlYWQ6IHRydWUgfSlcclxuICAgICAgLmVxKCdpZCcsIGlkKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgfSxcclxuXHJcbiAgLy8gQXNzaWdubWVudCBSdWxlc1xyXG4gIGFzeW5jIGdldEFzc2lnbm1lbnRSdWxlcygpIHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdhc3NpZ25tZW50X3J1bGVzJylcclxuICAgICAgLnNlbGVjdCgnKiwgY2F0ZWdvcmllcyhuYW1lKScpXHJcbiAgICAgIC5vcmRlcigncGF0dGVybicpO1xyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH0sXHJcblxyXG4gIGFzeW5jIGNyZWF0ZUFzc2lnbm1lbnRSdWxlKHJ1bGU6IHsgcGF0dGVybjogc3RyaW5nOyBjYXRlZ29yeV9pZDogc3RyaW5nIH0pIHtcclxuICAgIGNvbnN0IHsgZGF0YTogdXNlciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnYXNzaWdubWVudF9ydWxlcycpXHJcbiAgICAgIC5pbnNlcnQoW3sgLi4ucnVsZSwgdXNlcl9pZDogdXNlcj8udXNlcj8uaWQsIGlzX2FjdGl2ZTogdHJ1ZSB9XSlcclxuICAgICAgLnNlbGVjdCgpXHJcbiAgICAgIC5zaW5nbGUoKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9LFxyXG5cclxuICBhc3luYyBkZWxldGVBc3NpZ25tZW50UnVsZShpZDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnYXNzaWdubWVudF9ydWxlcycpXHJcbiAgICAgIC5kZWxldGUoKVxyXG4gICAgICAuZXEoJ2lkJywgaWQpO1xyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICB9LFxyXG5cclxuICBhc3luYyB1cGRhdGVBc3NpZ25tZW50UnVsZShpZDogc3RyaW5nLCB1cGRhdGVzOiB7IHBhdHRlcm4/OiBzdHJpbmc7IGNhdGVnb3J5X2lkPzogc3RyaW5nIH0pIHtcclxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdhc3NpZ25tZW50X3J1bGVzJylcclxuICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxyXG4gICAgICAuZXEoJ2lkJywgaWQpO1xyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICB9LFxyXG5cclxuICAvLyBTdGF0c1xyXG4gIGFzeW5jIGdldENhdGVnb3J5U3RhdHMoc3RhcnREYXRlOiBzdHJpbmcsIGVuZERhdGU6IHN0cmluZykge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3RyYW5zYWN0aW9ucycpXHJcbiAgICAgIC5zZWxlY3QoYFxyXG4gICAgICAgIGNhdGVnb3J5X2lkLFxyXG4gICAgICAgIGNoYXJnZWRfYW1vdW50LFxyXG4gICAgICAgIGNhdGVnb3JpZXMobmFtZSwgdGFyZ2V0X2Ftb3VudClcclxuICAgICAgYClcclxuICAgICAgLmd0ZSgnZGF0ZScsIHN0YXJ0RGF0ZSlcclxuICAgICAgLmx0ZSgnZGF0ZScsIGVuZERhdGUpO1xyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH0sXHJcblxyXG4gIC8vIFJlc2V0IGFsbCBkYXRhIChrZWVwcyBiYW5rX3VzZXJfYWNjb3VudHMgY3JlZGVudGlhbHMpXHJcbiAgYXN5bmMgcmVzZXRBbGxEYXRhKCkge1xyXG4gICAgLy8gRGVsZXRlIGluIG9yZGVyIGR1ZSB0byBmb3JlaWduIGtleSBjb25zdHJhaW50c1xyXG4gICAgLy8gMS4gRGVsZXRlIHJlY3VycmluZyAocmVmZXJlbmNlcyBiYW5rX2FjY291bnRzKVxyXG4gICAgY29uc3QgeyBlcnJvcjogcmVjdXJyaW5nRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdyZWN1cnJpbmcnKVxyXG4gICAgICAuZGVsZXRlKClcclxuICAgICAgLm5lcSgnaWQnLCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJyk7IC8vIERlbGV0ZSBhbGxcclxuICAgIGlmIChyZWN1cnJpbmdFcnJvcikgdGhyb3cgcmVjdXJyaW5nRXJyb3I7XHJcblxyXG4gICAgLy8gMi4gRGVsZXRlIHRyYW5zYWN0aW9ucyAocmVmZXJlbmNlcyBiYW5rX2FjY291bnRzKVxyXG4gICAgY29uc3QgeyBlcnJvcjogdHhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3RyYW5zYWN0aW9ucycpXHJcbiAgICAgIC5kZWxldGUoKVxyXG4gICAgICAubmVxKCdpZCcsICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnKTtcclxuICAgIGlmICh0eEVycm9yKSB0aHJvdyB0eEVycm9yO1xyXG5cclxuICAgIC8vIDMuIERlbGV0ZSBiYW5rX2FjY291bnRzIChyZWZlcmVuY2VzIGJhbmtfdXNlcl9hY2NvdW50cylcclxuICAgIGNvbnN0IHsgZXJyb3I6IGFjY291bnRzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdiYW5rX2FjY291bnRzJylcclxuICAgICAgLmRlbGV0ZSgpXHJcbiAgICAgIC5uZXEoJ2lkJywgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCcpO1xyXG4gICAgaWYgKGFjY291bnRzRXJyb3IpIHRocm93IGFjY291bnRzRXJyb3I7XHJcblxyXG4gICAgLy8gNC4gRGVsZXRlIGNhdGVnb3JpZXNcclxuICAgIGNvbnN0IHsgZXJyb3I6IGNhdEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnY2F0ZWdvcmllcycpXHJcbiAgICAgIC5kZWxldGUoKVxyXG4gICAgICAubmVxKCdpZCcsICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnKTtcclxuICAgIGlmIChjYXRFcnJvcikgdGhyb3cgY2F0RXJyb3I7XHJcblxyXG4gICAgLy8gNS4gRGVsZXRlIGFzc2lnbm1lbnRfcnVsZXNcclxuICAgIGNvbnN0IHsgZXJyb3I6IHJ1bGVzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdhc3NpZ25tZW50X3J1bGVzJylcclxuICAgICAgLmRlbGV0ZSgpXHJcbiAgICAgIC5uZXEoJ2lkJywgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCcpO1xyXG4gICAgaWYgKHJ1bGVzRXJyb3IpIHRocm93IHJ1bGVzRXJyb3I7XHJcblxyXG4gICAgLy8gNi4gRGVsZXRlIGxvZ3NcclxuICAgIGNvbnN0IHsgZXJyb3I6IGxvZ3NFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2xvZ3MnKVxyXG4gICAgICAuZGVsZXRlKClcclxuICAgICAgLm5lcSgnaWQnLCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJyk7XHJcbiAgICBpZiAobG9nc0Vycm9yKSB0aHJvdyBsb2dzRXJyb3I7XHJcblxyXG4gICAgLy8gNy4gUmVzZXQgbGFzdF91cGRhdGVkIGluIGJhbmtfdXNlcl9hY2NvdW50cyB0byB0cmlnZ2VyIGZ1bGwgcmUtc3luY1xyXG4gICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdiYW5rX3VzZXJfYWNjb3VudHMnKVxyXG4gICAgICAudXBkYXRlKHsgbGFzdF91cGRhdGVkOiBudWxsIH0pXHJcbiAgICAgIC5uZXEoJ2lkJywgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCcpO1xyXG4gICAgaWYgKHVwZGF0ZUVycm9yKSB0aHJvdyB1cGRhdGVFcnJvcjtcclxuICB9LFxyXG5cclxuICAvLyBEZWxldGUgYSBiYW5rIHVzZXIgYWNjb3VudCBhbmQgYWxsIGl0cyBkYXRhXHJcbiAgYXN5bmMgZGVsZXRlQmFua1VzZXJBY2NvdW50KHVzZXJBY2NvdW50SWQ6IHN0cmluZykge1xyXG4gICAgLy8gQ0FTQ0FERSB3aWxsIGhhbmRsZSBiYW5rX2FjY291bnRzLCB0cmFuc2FjdGlvbnMsIHJlY3VycmluZ1xyXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2JhbmtfdXNlcl9hY2NvdW50cycpXHJcbiAgICAgIC5kZWxldGUoKVxyXG4gICAgICAuZXEoJ2lkJywgdXNlckFjY291bnRJZCk7XHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gIH0sXHJcblxyXG4gIC8vIEdldCBiYW5rIHVzZXIgYWNjb3VudHMgKGZvciBsaXN0aW5nIGFjY291bnRzIHRvIGRlbGV0ZSlcclxuICBhc3luYyBnZXRCYW5rVXNlckFjY291bnRzKCkge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2JhbmtfdXNlcl9hY2NvdW50cycpXHJcbiAgICAgIC5zZWxlY3QoJ2lkLCBiYW5rX3R5cGUsIGNyZWF0ZWRfYXQnKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9LFxyXG59O1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJzdXBhYmFzZSIsIkNSRURJVF9DQVJEX1RZUEVTIiwiYXBpIiwiZ2V0QWNjb3VudHMiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJvciIsImdldENyZWRpdENhcmRVcGNvbWluZ0NoYXJnZXMiLCJhY2NvdW50SWQiLCJub3ciLCJEYXRlIiwic3RhcnRPZk1vbnRoIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsInRvSVNPU3RyaW5nIiwiZW5kT2ZOZXh0TW9udGgiLCJndGUiLCJsdGUiLCJ0b3RhbCIsInJlZHVjZSIsInN1bSIsInR4IiwiY2hhcmdlZF9hbW91bnQiLCJNYXRoIiwiYWJzIiwiZ2V0VHJhbnNhY3Rpb25zIiwiZmlsdGVycyIsInF1ZXJ5Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJzdGFydERhdGUiLCJlbmREYXRlIiwic2VhcmNoIiwiaWxpa2UiLCJsaW1pdCIsInVwZGF0ZVRyYW5zYWN0aW9uQ2F0ZWdvcnkiLCJ0cmFuc2FjdGlvbklkcyIsImNhdGVnb3J5SWQiLCJ1cGRhdGUiLCJjYXRlZ29yeV9pZCIsImluIiwiZ2V0Q2F0ZWdvcmllcyIsImNyZWF0ZUNhdGVnb3J5IiwiY2F0ZWdvcnkiLCJ1c2VyIiwiYXV0aCIsImdldFVzZXIiLCJpbnNlcnQiLCJ1c2VyX2lkIiwiaWQiLCJzaW5nbGUiLCJ1cGRhdGVDYXRlZ29yeSIsInVwZGF0ZXMiLCJnZXRSZWN1cnJpbmciLCJnZXRQZW5kaW5nUmVjdXJyaW5nQ291bnQiLCJjb3VudCIsImhlYWQiLCJuZXEiLCJjb25maXJtUmVjdXJyaW5nIiwiY29uZmlybWVkIiwiaXNfY29uZmlybWVkIiwiZ2V0Tm90aWZpY2F0aW9ucyIsIm1hcmtOb3RpZmljYXRpb25SZWFkIiwiaXNfcmVhZCIsImdldEFzc2lnbm1lbnRSdWxlcyIsImNyZWF0ZUFzc2lnbm1lbnRSdWxlIiwicnVsZSIsImlzX2FjdGl2ZSIsImRlbGV0ZUFzc2lnbm1lbnRSdWxlIiwiZGVsZXRlIiwidXBkYXRlQXNzaWdubWVudFJ1bGUiLCJnZXRDYXRlZ29yeVN0YXRzIiwicmVzZXRBbGxEYXRhIiwicmVjdXJyaW5nRXJyb3IiLCJ0eEVycm9yIiwiYWNjb3VudHNFcnJvciIsImNhdEVycm9yIiwicnVsZXNFcnJvciIsImxvZ3NFcnJvciIsInVwZGF0ZUVycm9yIiwibGFzdF91cGRhdGVkIiwiZGVsZXRlQmFua1VzZXJBY2NvdW50IiwidXNlckFjY291bnRJZCIsImdldEJhbmtVc2VyQWNjb3VudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase.ts\n"));

/***/ })

});