"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/rules/page",{

/***/ "(app-pages-browser)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CREDIT_CARD_TYPES: function() { return /* binding */ CREDIT_CARD_TYPES; },\n/* harmony export */   api: function() { return /* binding */ api; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/index.mjs\");\n\nconst supabaseUrl = \"https://zqfulrwysdtnvogicldy.supabase.co\";\nconst supabaseAnonKey = \"sb_publishable_krVfM1a4y5BtRrFEX4hgxw_mE5XbEte\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Credit card types that should show upcoming charges instead of balance\nconst CREDIT_CARD_TYPES = [\n    \"isracard\",\n    \"amex\",\n    \"max\",\n    \"visaCal\"\n];\n// API functions\nconst api = {\n    // Accounts\n    async getAccounts () {\n        const { data, error } = await supabase.from(\"bank_accounts\").select(\"*\").eq(\"is_active\", true).or(\"is_cancelled.is.null,is_cancelled.eq.false\"); // Filter out cancelled cards\n        if (error) throw error;\n        return data;\n    },\n    // Get upcoming credit card charges (sum of charged_amount for pending transactions)\n    async getCreditCardUpcomingCharges (accountId) {\n        // Get transactions from current month that haven't been processed yet\n        const now = new Date();\n        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();\n        const endOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 2, 0).toISOString();\n        const { data, error } = await supabase.from(\"transactions\").select(\"charged_amount\").eq(\"account_id\", accountId).gte(\"date\", startOfMonth).lte(\"date\", endOfNextMonth);\n        if (error) throw error;\n        // Sum all charged amounts (they are negative for expenses)\n        const total = (data || []).reduce((sum, tx)=>sum + (tx.charged_amount || 0), 0);\n        return Math.abs(total); // Return as positive number\n    },\n    // Transactions\n    async getTransactions (filters) {\n        let query = supabase.from(\"transactions\").select(\"\\n        *,\\n        bank_accounts!inner(bank_type)\\n      \").order(\"date\", {\n            ascending: false\n        });\n        if (filters === null || filters === void 0 ? void 0 : filters.accountId) {\n            query = query.eq(\"account_id\", filters.accountId);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.startDate) {\n            query = query.gte(\"date\", filters.startDate);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.endDate) {\n            query = query.lte(\"date\", filters.endDate);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.search) {\n            query = query.ilike(\"description\", \"%\".concat(filters.search, \"%\"));\n        }\n        const { data, error } = await query.limit(500);\n        if (error) throw error;\n        return data;\n    },\n    async updateTransactionCategory (transactionIds, categoryId) {\n        const { error } = await supabase.from(\"transactions\").update({\n            category_id: categoryId\n        }).in(\"id\", transactionIds);\n        if (error) throw error;\n    },\n    // Categories\n    async getCategories () {\n        const { data, error } = await supabase.from(\"categories\").select(\"*\").order(\"name\");\n        if (error) throw error;\n        return data;\n    },\n    async createCategory (category) {\n        var _user_user;\n        const { data: user } = await supabase.auth.getUser();\n        const { data, error } = await supabase.from(\"categories\").insert([\n            {\n                ...category,\n                user_id: user === null || user === void 0 ? void 0 : (_user_user = user.user) === null || _user_user === void 0 ? void 0 : _user_user.id\n            }\n        ]).select().single();\n        if (error) throw error;\n        return data;\n    },\n    async updateCategory (id, updates) {\n        const { error } = await supabase.from(\"categories\").update(updates).eq(\"id\", id);\n        if (error) throw error;\n    },\n    // Recurring\n    async getRecurring () {\n        const { data, error } = await supabase.from(\"recurring\").select(\"*\").order(\"amount_avg\", {\n            ascending: false\n        });\n        if (error) throw error;\n        return data;\n    },\n    async getPendingRecurringCount () {\n        // Only count non-installment recurring as pending (installments are auto-approved)\n        const { count, error } = await supabase.from(\"recurring\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"is_confirmed\", false).neq(\"type\", \"installment\");\n        if (error) throw error;\n        return count || 0;\n    },\n    async confirmRecurring (id, confirmed) {\n        const { error } = await supabase.from(\"recurring\").update({\n            is_confirmed: confirmed\n        }).eq(\"id\", id);\n        if (error) throw error;\n    },\n    // Notifications\n    async getNotifications () {\n        const { data, error } = await supabase.from(\"notifications\").select(\"*\").order(\"created_at\", {\n            ascending: false\n        }).limit(50);\n        if (error) throw error;\n        return data;\n    },\n    async markNotificationRead (id) {\n        const { error } = await supabase.from(\"notifications\").update({\n            is_read: true\n        }).eq(\"id\", id);\n        if (error) throw error;\n    },\n    // Assignment Rules\n    async getAssignmentRules () {\n        const { data, error } = await supabase.from(\"assignment_rules\").select(\"*, categories(name)\").order(\"pattern\");\n        if (error) throw error;\n        return data;\n    },\n    async createAssignmentRule (rule) {\n        var _user_user;\n        const { data: user } = await supabase.auth.getUser();\n        const { data, error } = await supabase.from(\"assignment_rules\").insert([\n            {\n                ...rule,\n                user_id: user === null || user === void 0 ? void 0 : (_user_user = user.user) === null || _user_user === void 0 ? void 0 : _user_user.id,\n                is_active: true\n            }\n        ]).select().single();\n        if (error) throw error;\n        return data;\n    },\n    async deleteAssignmentRule (id) {\n        const { error } = await supabase.from(\"assignment_rules\").delete().eq(\"id\", id);\n        if (error) throw error;\n    },\n    async updateAssignmentRule (id, updates) {\n        const { error } = await supabase.from(\"assignment_rules\").update(updates).eq(\"id\", id);\n        if (error) throw error;\n    },\n    // Stats\n    async getCategoryStats (startDate, endDate) {\n        const { data, error } = await supabase.from(\"transactions\").select(\"\\n        category_id,\\n        charged_amount,\\n        categories(name, target_amount)\\n      \").gte(\"date\", startDate).lte(\"date\", endDate);\n        if (error) throw error;\n        return data;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVFjLFdBQ1piLEdBQUcsQ0FBQyxRQUFRYztRQUNmLElBQUk3QixPQUFPLE1BQU1BO1FBQ2pCLE9BQU9EO0lBQ1Q7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvc3VwYWJhc2UudHM/MDZlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xyXG5cclxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhO1xyXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSE7XHJcblxyXG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSk7XHJcblxyXG4vLyBUeXBlcyBmb3IgZGF0YWJhc2UgdGFibGVzXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWNjb3VudCB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBiYW5rX25hbWU6IHN0cmluZztcclxuICBiYW5rX3R5cGU6IHN0cmluZztcclxuICBhY2NvdW50X251bWJlcj86IHN0cmluZztcclxuICBkZXNjcmlwdGlvbj86IHN0cmluZztcclxuICBsYXN0X3N5bmM/OiBzdHJpbmc7XHJcbiAgbGFzdF91cGRhdGVkOiBzdHJpbmc7XHJcbiAgc3RhdHVzOiAnYWN0aXZlJyB8ICdpbmFjdGl2ZScgfCAnZXJyb3InO1xyXG4gIGN1cnJlbnRfYmFsYW5jZT86IG51bWJlcjtcclxuICBiYWxhbmNlPzogbnVtYmVyO1xyXG4gIGlzX2NhbmNlbGxlZD86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb24ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgYWNjb3VudF9pZDogc3RyaW5nO1xyXG4gIGRhdGU6IHN0cmluZztcclxuICBwcm9jZXNzZWRfZGF0ZT86IHN0cmluZztcclxuICBvcmlnaW5hbF9hbW91bnQ6IG51bWJlcjtcclxuICBvcmlnaW5hbF9jdXJyZW5jeTogc3RyaW5nO1xyXG4gIGNoYXJnZWRfYW1vdW50OiBudW1iZXI7XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICBtZW1vPzogc3RyaW5nO1xyXG4gIHR5cGU6IHN0cmluZztcclxuICBjYXRlZ29yeV9pZD86IHN0cmluZztcclxuICBpbnN0YWxsbWVudF9udW1iZXI/OiBudW1iZXI7XHJcbiAgaW5zdGFsbG1lbnRfdG90YWw/OiBudW1iZXI7XHJcbiAgaGFzaDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENhdGVnb3J5IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHVzZXJfaWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgdGFyZ2V0X2Ftb3VudD86IG51bWJlcjtcclxuICBpY29uPzogc3RyaW5nO1xyXG4gIGNvbG9yPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlY3VycmluZyB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBhY2NvdW50X2lkOiBzdHJpbmc7XHJcbiAgdHlwZTogJ2luc3RhbGxtZW50JyB8ICdkaXJlY3RfZGViaXQnIHwgJ2RldGVjdGVkJztcclxuICBhdmVyYWdlX2Ftb3VudDogbnVtYmVyO1xyXG4gIGFtb3VudF9hdmc6IG51bWJlcjtcclxuICBleHBlY3RlZF9kYXk/OiBudW1iZXI7XHJcbiAgZGF5X29mX21vbnRoPzogbnVtYmVyO1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgaXNfY29uZmlybWVkOiBib29sZWFuO1xyXG4gIGluc3RhbGxtZW50X3RvdGFsPzogbnVtYmVyOyAvLyBUb3RhbCBpbnN0YWxsbWVudHNcclxuICBpbnN0YWxsbWVudF9jdXJyZW50PzogbnVtYmVyOyAvLyBDdXJyZW50IGluc3RhbGxtZW50IHdoZW4gZmlyc3QgZGV0ZWN0ZWRcclxuICBmaXJzdF9kZXRlY3RlZF9kYXRlPzogc3RyaW5nOyAvLyBEYXRlIHdoZW4gZmlyc3QgZGV0ZWN0ZWRcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUmVjdXJyaW5nSXRlbSA9IFJlY3VycmluZztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHVzZXJfaWQ6IHN0cmluZztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIG1lc3NhZ2U6IHN0cmluZztcclxuICBpc19yZWFkOiBib29sZWFuO1xyXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBc3NpZ25tZW50UnVsZSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB1c2VyX2lkOiBzdHJpbmc7XHJcbiAgcGF0dGVybjogc3RyaW5nO1xyXG4gIGNhdGVnb3J5X2lkOiBzdHJpbmc7XHJcbiAgaXNfYWN0aXZlOiBib29sZWFuO1xyXG59XHJcblxyXG4vLyBDcmVkaXQgY2FyZCB0eXBlcyB0aGF0IHNob3VsZCBzaG93IHVwY29taW5nIGNoYXJnZXMgaW5zdGVhZCBvZiBiYWxhbmNlXHJcbmV4cG9ydCBjb25zdCBDUkVESVRfQ0FSRF9UWVBFUyA9IFsnaXNyYWNhcmQnLCAnYW1leCcsICdtYXgnLCAndmlzYUNhbCddO1xyXG5cclxuLy8gQVBJIGZ1bmN0aW9uc1xyXG5leHBvcnQgY29uc3QgYXBpID0ge1xyXG4gIC8vIEFjY291bnRzXHJcbiAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnYmFua19hY2NvdW50cycpXHJcbiAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXHJcbiAgICAgIC5vcignaXNfY2FuY2VsbGVkLmlzLm51bGwsaXNfY2FuY2VsbGVkLmVxLmZhbHNlJyk7IC8vIEZpbHRlciBvdXQgY2FuY2VsbGVkIGNhcmRzXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfSxcclxuXHJcbiAgLy8gR2V0IHVwY29taW5nIGNyZWRpdCBjYXJkIGNoYXJnZXMgKHN1bSBvZiBjaGFyZ2VkX2Ftb3VudCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMpXHJcbiAgYXN5bmMgZ2V0Q3JlZGl0Q2FyZFVwY29taW5nQ2hhcmdlcyhhY2NvdW50SWQ6IHN0cmluZykge1xyXG4gICAgLy8gR2V0IHRyYW5zYWN0aW9ucyBmcm9tIGN1cnJlbnQgbW9udGggdGhhdCBoYXZlbid0IGJlZW4gcHJvY2Vzc2VkIHlldFxyXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgIGNvbnN0IHN0YXJ0T2ZNb250aCA9IG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgMSkudG9JU09TdHJpbmcoKTtcclxuICAgIGNvbnN0IGVuZE9mTmV4dE1vbnRoID0gbmV3IERhdGUobm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpICsgMiwgMCkudG9JU09TdHJpbmcoKTtcclxuICAgIFxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3RyYW5zYWN0aW9ucycpXHJcbiAgICAgIC5zZWxlY3QoJ2NoYXJnZWRfYW1vdW50JylcclxuICAgICAgLmVxKCdhY2NvdW50X2lkJywgYWNjb3VudElkKVxyXG4gICAgICAuZ3RlKCdkYXRlJywgc3RhcnRPZk1vbnRoKVxyXG4gICAgICAubHRlKCdkYXRlJywgZW5kT2ZOZXh0TW9udGgpO1xyXG4gICAgXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gICAgXHJcbiAgICAvLyBTdW0gYWxsIGNoYXJnZWQgYW1vdW50cyAodGhleSBhcmUgbmVnYXRpdmUgZm9yIGV4cGVuc2VzKVxyXG4gICAgY29uc3QgdG90YWwgPSAoZGF0YSB8fCBbXSkucmVkdWNlKChzdW0sIHR4KSA9PiBzdW0gKyAodHguY2hhcmdlZF9hbW91bnQgfHwgMCksIDApO1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKHRvdGFsKTsgLy8gUmV0dXJuIGFzIHBvc2l0aXZlIG51bWJlclxyXG4gIH0sXHJcblxyXG4gIC8vIFRyYW5zYWN0aW9uc1xyXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9ucyhmaWx0ZXJzPzoge1xyXG4gICAgYWNjb3VudElkPzogc3RyaW5nO1xyXG4gICAgc3RhcnREYXRlPzogc3RyaW5nO1xyXG4gICAgZW5kRGF0ZT86IHN0cmluZztcclxuICAgIGNhdGVnb3J5Pzogc3RyaW5nO1xyXG4gICAgc2VhcmNoPzogc3RyaW5nO1xyXG4gIH0pIHtcclxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCd0cmFuc2FjdGlvbnMnKVxyXG4gICAgICAuc2VsZWN0KGBcclxuICAgICAgICAqLFxyXG4gICAgICAgIGJhbmtfYWNjb3VudHMhaW5uZXIoYmFua190eXBlKVxyXG4gICAgICBgKVxyXG4gICAgICAub3JkZXIoJ2RhdGUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XHJcblxyXG4gICAgaWYgKGZpbHRlcnM/LmFjY291bnRJZCkge1xyXG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdhY2NvdW50X2lkJywgZmlsdGVycy5hY2NvdW50SWQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZpbHRlcnM/LnN0YXJ0RGF0ZSkge1xyXG4gICAgICBxdWVyeSA9IHF1ZXJ5Lmd0ZSgnZGF0ZScsIGZpbHRlcnMuc3RhcnREYXRlKTtcclxuICAgIH1cclxuICAgIGlmIChmaWx0ZXJzPy5lbmREYXRlKSB7XHJcbiAgICAgIHF1ZXJ5ID0gcXVlcnkubHRlKCdkYXRlJywgZmlsdGVycy5lbmREYXRlKTtcclxuICAgIH1cclxuICAgIGlmIChmaWx0ZXJzPy5zZWFyY2gpIHtcclxuICAgICAgcXVlcnkgPSBxdWVyeS5pbGlrZSgnZGVzY3JpcHRpb24nLCBgJSR7ZmlsdGVycy5zZWFyY2h9JWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5LmxpbWl0KDUwMCk7XHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgdXBkYXRlVHJhbnNhY3Rpb25DYXRlZ29yeSh0cmFuc2FjdGlvbklkczogc3RyaW5nW10sIGNhdGVnb3J5SWQ6IHN0cmluZykge1xyXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3RyYW5zYWN0aW9ucycpXHJcbiAgICAgIC51cGRhdGUoeyBjYXRlZ29yeV9pZDogY2F0ZWdvcnlJZCB9KVxyXG4gICAgICAuaW4oJ2lkJywgdHJhbnNhY3Rpb25JZHMpO1xyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICB9LFxyXG5cclxuICAvLyBDYXRlZ29yaWVzXHJcbiAgYXN5bmMgZ2V0Q2F0ZWdvcmllcygpIHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdjYXRlZ29yaWVzJylcclxuICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgIC5vcmRlcignbmFtZScpO1xyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH0sXHJcblxyXG4gIGFzeW5jIGNyZWF0ZUNhdGVnb3J5KGNhdGVnb3J5OiBQYXJ0aWFsPENhdGVnb3J5Pikge1xyXG4gICAgY29uc3QgeyBkYXRhOiB1c2VyIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdjYXRlZ29yaWVzJylcclxuICAgICAgLmluc2VydChbeyAuLi5jYXRlZ29yeSwgdXNlcl9pZDogdXNlcj8udXNlcj8uaWQgfV0pXHJcbiAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgdXBkYXRlQ2F0ZWdvcnkoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxDYXRlZ29yeT4pIHtcclxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdjYXRlZ29yaWVzJylcclxuICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxyXG4gICAgICAuZXEoJ2lkJywgaWQpO1xyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICB9LFxyXG5cclxuICAvLyBSZWN1cnJpbmdcclxuICBhc3luYyBnZXRSZWN1cnJpbmcoKSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgncmVjdXJyaW5nJylcclxuICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgIC5vcmRlcignYW1vdW50X2F2ZycsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9LFxyXG5cclxuICBhc3luYyBnZXRQZW5kaW5nUmVjdXJyaW5nQ291bnQoKSB7XHJcbiAgICAvLyBPbmx5IGNvdW50IG5vbi1pbnN0YWxsbWVudCByZWN1cnJpbmcgYXMgcGVuZGluZyAoaW5zdGFsbG1lbnRzIGFyZSBhdXRvLWFwcHJvdmVkKVxyXG4gICAgY29uc3QgeyBjb3VudCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdyZWN1cnJpbmcnKVxyXG4gICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxyXG4gICAgICAuZXEoJ2lzX2NvbmZpcm1lZCcsIGZhbHNlKVxyXG4gICAgICAubmVxKCd0eXBlJywgJ2luc3RhbGxtZW50Jyk7XHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gICAgcmV0dXJuIGNvdW50IHx8IDA7XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgY29uZmlybVJlY3VycmluZyhpZDogc3RyaW5nLCBjb25maXJtZWQ6IGJvb2xlYW4pIHtcclxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdyZWN1cnJpbmcnKVxyXG4gICAgICAudXBkYXRlKHsgaXNfY29uZmlybWVkOiBjb25maXJtZWQgfSlcclxuICAgICAgLmVxKCdpZCcsIGlkKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgfSxcclxuXHJcbiAgLy8gTm90aWZpY2F0aW9uc1xyXG4gIGFzeW5jIGdldE5vdGlmaWNhdGlvbnMoKSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnbm90aWZpY2F0aW9ucycpXHJcbiAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICAgICAgLmxpbWl0KDUwKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9LFxyXG5cclxuICBhc3luYyBtYXJrTm90aWZpY2F0aW9uUmVhZChpZDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnbm90aWZpY2F0aW9ucycpXHJcbiAgICAgIC51cGRhdGUoeyBpc19yZWFkOiB0cnVlIH0pXHJcbiAgICAgIC5lcSgnaWQnLCBpZCk7XHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gIH0sXHJcblxyXG4gIC8vIEFzc2lnbm1lbnQgUnVsZXNcclxuICBhc3luYyBnZXRBc3NpZ25tZW50UnVsZXMoKSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnYXNzaWdubWVudF9ydWxlcycpXHJcbiAgICAgIC5zZWxlY3QoJyosIGNhdGVnb3JpZXMobmFtZSknKVxyXG4gICAgICAub3JkZXIoJ3BhdHRlcm4nKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9LFxyXG5cclxuICBhc3luYyBjcmVhdGVBc3NpZ25tZW50UnVsZShydWxlOiB7IHBhdHRlcm46IHN0cmluZzsgY2F0ZWdvcnlfaWQ6IHN0cmluZyB9KSB7XHJcbiAgICBjb25zdCB7IGRhdGE6IHVzZXIgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2Fzc2lnbm1lbnRfcnVsZXMnKVxyXG4gICAgICAuaW5zZXJ0KFt7IC4uLnJ1bGUsIHVzZXJfaWQ6IHVzZXI/LnVzZXI/LmlkLCBpc19hY3RpdmU6IHRydWUgfV0pXHJcbiAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgZGVsZXRlQXNzaWdubWVudFJ1bGUoaWQ6IHN0cmluZykge1xyXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2Fzc2lnbm1lbnRfcnVsZXMnKVxyXG4gICAgICAuZGVsZXRlKClcclxuICAgICAgLmVxKCdpZCcsIGlkKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgdXBkYXRlQXNzaWdubWVudFJ1bGUoaWQ6IHN0cmluZywgdXBkYXRlczogeyBwYXR0ZXJuPzogc3RyaW5nOyBjYXRlZ29yeV9pZD86IHN0cmluZyB9KSB7XHJcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnYXNzaWdubWVudF9ydWxlcycpXHJcbiAgICAgIC51cGRhdGUodXBkYXRlcylcclxuICAgICAgLmVxKCdpZCcsIGlkKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgfSxcclxuXHJcbiAgLy8gU3RhdHNcclxuICBhc3luYyBnZXRDYXRlZ29yeVN0YXRzKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCd0cmFuc2FjdGlvbnMnKVxyXG4gICAgICAuc2VsZWN0KGBcclxuICAgICAgICBjYXRlZ29yeV9pZCxcclxuICAgICAgICBjaGFyZ2VkX2Ftb3VudCxcclxuICAgICAgICBjYXRlZ29yaWVzKG5hbWUsIHRhcmdldF9hbW91bnQpXHJcbiAgICAgIGApXHJcbiAgICAgIC5ndGUoJ2RhdGUnLCBzdGFydERhdGUpXHJcbiAgICAgIC5sdGUoJ2RhdGUnLCBlbmREYXRlKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9LFxyXG59O1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJzdXBhYmFzZSIsIkNSRURJVF9DQVJEX1RZUEVTIiwiYXBpIiwiZ2V0QWNjb3VudHMiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJvciIsImdldENyZWRpdENhcmRVcGNvbWluZ0NoYXJnZXMiLCJhY2NvdW50SWQiLCJub3ciLCJEYXRlIiwic3RhcnRPZk1vbnRoIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsInRvSVNPU3RyaW5nIiwiZW5kT2ZOZXh0TW9udGgiLCJndGUiLCJsdGUiLCJ0b3RhbCIsInJlZHVjZSIsInN1bSIsInR4IiwiY2hhcmdlZF9hbW91bnQiLCJNYXRoIiwiYWJzIiwiZ2V0VHJhbnNhY3Rpb25zIiwiZmlsdGVycyIsInF1ZXJ5Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJzdGFydERhdGUiLCJlbmREYXRlIiwic2VhcmNoIiwiaWxpa2UiLCJsaW1pdCIsInVwZGF0ZVRyYW5zYWN0aW9uQ2F0ZWdvcnkiLCJ0cmFuc2FjdGlvbklkcyIsImNhdGVnb3J5SWQiLCJ1cGRhdGUiLCJjYXRlZ29yeV9pZCIsImluIiwiZ2V0Q2F0ZWdvcmllcyIsImNyZWF0ZUNhdGVnb3J5IiwiY2F0ZWdvcnkiLCJ1c2VyIiwiYXV0aCIsImdldFVzZXIiLCJpbnNlcnQiLCJ1c2VyX2lkIiwiaWQiLCJzaW5nbGUiLCJ1cGRhdGVDYXRlZ29yeSIsInVwZGF0ZXMiLCJnZXRSZWN1cnJpbmciLCJnZXRQZW5kaW5nUmVjdXJyaW5nQ291bnQiLCJjb3VudCIsImhlYWQiLCJuZXEiLCJjb25maXJtUmVjdXJyaW5nIiwiY29uZmlybWVkIiwiaXNfY29uZmlybWVkIiwiZ2V0Tm90aWZpY2F0aW9ucyIsIm1hcmtOb3RpZmljYXRpb25SZWFkIiwiaXNfcmVhZCIsImdldEFzc2lnbm1lbnRSdWxlcyIsImNyZWF0ZUFzc2lnbm1lbnRSdWxlIiwicnVsZSIsImlzX2FjdGl2ZSIsImRlbGV0ZUFzc2lnbm1lbnRSdWxlIiwiZGVsZXRlIiwidXBkYXRlQXNzaWdubWVudFJ1bGUiLCJnZXRDYXRlZ29yeVN0YXRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase.ts\n"));

/***/ })

});